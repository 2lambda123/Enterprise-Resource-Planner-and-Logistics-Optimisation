
import { Component, TemplateRef, OnInit, ViewChild, ChangeDetectorRef } from '@angular/core';
import { AuthService } from 'src/app/shared/auth.service';
import data from 'src/app/data/products';
import { FormControl, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { ColumnMode, DatatableComponent, SelectionType } from '@swimlane/ngx-datatable';
import { NgStyle } from "@angular/common";
import { Router } from '@angular/router'; 
import { BsModalRef, BsModalService } from 'ngx-bootstrap/modal';
import { Subscription, combineLatest } from 'rxjs';

export interface IBranch {
  branch_Id:       number;
  branch_Name:     string;
  branch_Location: BranchLocation;
}

export interface BranchLocation {
  location_Street:    string;
  location_Suburb:    string;
  location_City:      string;
  location_Zip_Code:  string;
  location_Longitude: number;
  location_Latitude:  number;
  location_Places_Id: string;
}



// Generated by https://quicktype.io

export interface IRoutes {
  route_Id:        number;
  route_ETA:       string;
  driver:          DriverClass;
  route_Driver_Id: number;
  route_Completed: string;
  orders:          Order[];
}

// Generated by https://quicktype.io

export interface DriverClass {
  emp_Id:         number;
  emp_First_Name: string;
  emp_Last_Name:  string;
}


export interface Order {
  order_Id:              number;
  order_Sequence_Number: number;
  order_Delivered:       boolean;
  order_Distance:        number;
  location:              Location;
}

export interface Location {
  location_Street:    string;
  location_Suburb:    string;
  location_City:      string;
  location_Zip_Code:  string;
  location_Longitude: number;
  location_Latitude:  number;
  location_Places_Id: string;
}


@Component({
  selector: 'app-maps',
  templateUrl: './maps.component.html'
})


export class MapsComponent implements OnInit {

  orderIcons = {
    url: '../../assets/img/iconsminds-pantone.svg',
    scaledSize: {
        width: 40,
        height: 60
    }
};

public manOrders : IRoutes[] =[];
public manOrdersIndex =0;

  public manOrderActiveOrders : Order[] = [] ;
  public manOrderCount : number = 0 ;
  public conOrders : IRoutes ;

  branch : IBranch;
  branchcount: number = 0;

  origin = {
    lat: 0.00,
    lng: 0.00
  };

  //track html loops of the lists
  trackByIndex;

  options;
  destination  = [];
  waypoints=[];

  public dirs: Array<any> = [];
  
  Color = require('color');
  color;
  str : {
    route_Id: Number,
    route_color: String
  }[] = [];



  //reactive route list items
  ColumnMode = ColumnMode;

  activeroutesform: FormGroup ;
  routesordersform: FormGroup;

  routesdisplayMode = 'list';
  orderdisplayMode = 'list';

  orderrouteBy = '';
  searchroute = '';
  totalRouteItem = 0;
  routeitemsPerPage = 10;
  routePage = 1;

  selectRouteAllState = '';
  selectRouteOrderAllState = '';
  routecount: number = 0;;
  //the total selected routes on the list
  activeRoutes : IRoutes[] = [];
  

  @ViewChild('template', { static: true }) template: TemplateRef<any>;


  //collapsing list
  isRouteCollapsed;
  isRouteCollapsedAnimated;

  constructor(private fb: FormBuilder,  private changeDetection: ChangeDetectorRef, private modalService: BsModalService, private authService: AuthService,  private router: Router) 
  { 
    this.isRouteCollapsedAnimated = [];
    this.isRouteCollapsed = [];
    this.loadRouteData(this.routeitemsPerPage, this.routePage, this.searchroute, this.orderrouteBy);

  }

  loadRouteData(pageSize: number = 10, currentPage: number = 1, search: string = '', orderBy: string = '') 
  {
  
    this.authService.getBranch().subscribe(data=> {
      
      this.branch = ({
        branch_Id: data.branch_Id,
        branch_Name: data.branch_Name,
        branch_Location: {
          location_City: data.branch_Location.location_City,
          location_Street: data.branch_Location.location_Street,
          location_Suburb: data.branch_Location.location_Suburb,
          location_Zip_Code: data.branch_Location.location_Zip_Code,
          location_Longitude: data.branch_Location.location_Longitude,
          location_Latitude: data.branch_Location.location_Latitude,
          location_Places_Id: data.branch_Location.location_Places_Id
        }
      });
      
      console.log('branch details: ',this.branch)
    },null,()=> {
      this.origin = {
        lat: this.branch.branch_Location.location_Latitude,
        lng: this.branch.branch_Location.location_Longitude
      };
  
     
      console.log(this.origin)
    });

    
    this.authService.ManagerRoutes().subscribe(data=> {
      
      console.log(data)
      //set colors


        for(let key in data)
        {
       

          this.isRouteCollapsedAnimated.push(true);
          this.isRouteCollapsed.push(true);

          if(data.hasOwnProperty(key))
          {
            this.manOrders.push(data[key]);
            console.log(this.manOrders)
                  //we only set the colors as the page loads for every route 
              let i1 = +(Math.random() * (255-0) + 0)
              let i2 = +(Math.random() * (255-0) + 0)
              let i3 = +(Math.random() * (255-0) + 0)
              
              this.color = this.Color.rgb(i1,i2,i3).hex();
              this.str.push(
                {
                  route_Id: this.manOrders[this.manOrders.length-1].route_Id,
                  route_color: this.color
                });

            this.manOrderCount++;
            console.log(this.str)
            this.manOrdersIndex++;
          }
        }

        for(let i = 0; i <  this.manOrders.length;i++)
        {
          console.log(this.manOrders[i])
          console.log(this.destination[i])
          this.waypoints = [];
            var directionsService = new google.maps.DirectionsService();
            
            var distresult : {
              result: google.maps.DirectionsResult,
              status:  google.maps.DirectionsStatus
            };

            var thedistance: number = 0;
            for(let iorder = 0; iorder <  this.manOrders[i].orders.length-1;iorder++)
            {
              this.waypoints.push({lat: this.manOrders[i].orders[iorder].location.location_Latitude,lng: this.manOrders[i].orders[iorder].location.location_Longitude})
            }
            var request = {
              origin: this.origin,
              destination: { lat: this.manOrders[i].orders[this.manOrders[i].orders.length-1].location.location_Latitude, lng: this.manOrders[i].orders[this.manOrders[i].orders.length-1].location.location_Longitude},
              waypoints: this.waypoints,
              travelMode: google.maps.TravelMode.DRIVING
            };

              directionsService.route(
              request, 
              (result: google.maps.DirectionsResult,
                status:  google.maps.DirectionsStatus) => this.calcRoutedist(result,this.manOrders[i].orders)
              );

            
          
              
        }

        
      
    },null,()=> {
 
      //this initialises the map with points
      this.activeRoutes = [...this.manOrders];
      //we should only ever pass the selected routes to initilize the map
    
      this.initMap(this.activeRoutes);
    });
  }

  orderRouteDist: {
    order_Id: number,
    order_Distance: number
  }[]=[];

  resultant: google.maps.DirectionsResult[] = [];

  //cancel order variables

  cancelOrdermodalRef: BsModalRef;
  cancelOrdersubscriptions: Subscription[] = [];
  cancelOrdermessages: string[] = [];

  cancelorderform = this.fb.group({
    txtcancelMsg : ['', Validators.required]
  })

  cancelorderModal(template: TemplateRef<any>) {
    this.cancelOrdermessages = [];

    const _combine = combineLatest(
      this.modalService.onShow,
      this.modalService.onShown,
      this.modalService.onHide,
      this.modalService.onHidden
    ).subscribe(() => this.changeDetection.markForCheck());

    this.cancelOrdersubscriptions.push(
      this.modalService.onShow.subscribe((reason: string) => {
        this.cancelOrdermessages.push(`onShow event has been fired`);
      })
    );
    this.cancelOrdersubscriptions.push(
      this.modalService.onShown.subscribe((reason: string) => {
        this.cancelOrdermessages.push(`onShown event has been fired`);
      })
    );
    this.cancelOrdersubscriptions.push(
      this.modalService.onHide.subscribe((reason: string) => {
        const _reason = reason ? `, dismissed by ${reason}` : '';
        this.cancelOrdermessages.push(`onHide event has been fired${_reason}`);
      })
    );
    this.cancelOrdersubscriptions.push(
      this.modalService.onHidden.subscribe((reason: string) => {
        const _reason = reason ? `, dismissed by ${reason}` : '';
        this.cancelOrdermessages.push(`onHidden event has been fired${_reason}`);
        this.cancelOrderunsubscribe();
      })
    );

    this.cancelOrdersubscriptions.push(_combine);

    this.cancelOrdermodalRef = this.modalService.show(template);
  }
  
  cancelOrderunsubscribe() {
    this.cancelOrdersubscriptions.forEach((subscription: Subscription) => {
      subscription.unsubscribe();
    });
    this.cancelOrdersubscriptions = [];
  }

  cancelOrder(orderId: number)
  {
    this.authService.postCancelOrder({"order_Id": orderId, "cancel_Reason": this.cancelorderform.value.txtcancelMsg}).subscribe(null,null,()=> {
      window.location.reload();
      });
  }

  deleteSelectedRoutes(): void
  {
    var routeIDs = [];

    for(let i = 0; i < this.activeRoutes.length;i++)
    {
      routeIDs.push(this.activeRoutes[i].route_Id);
    }

    console.log(routeIDs);

    this.authService.postDeleteRoutes(routeIDs).subscribe(null,null,()=> {
      window.location.reload();
      });
  }

  
  get myForm() {
    return this.cancelorderform.controls;
  }

  goToOrder(orderId: number)
  {
    console.log('order id: ',orderId)
    console.log('route: ',this.router.navigate(['/app/orders/forms/orderDetails', orderId]))
    this.router.navigate(['/app/orders/forms/orderDetails',orderId]);
  }

  //assign driver function
  optimise()
  {
    this.authService.optimise().subscribe(null,null,()=> {
     window.location.reload();
     });
  }

calcRoutedist(result: google.maps.DirectionsResult, activeOrders: Order[]): void
{

  for(let i = 0; i < activeOrders.length; i++)
  {
    var totDist = 0.0;
   
     
     // this.orderRouteDist.push(+result.routes[0].legs[0].distance.text.toString().split(' ')[0]); 
     this.resultant.push(result);
     totDist += (+result.routes[0].legs[i].distance.text.toString().split(' ')[0])
     this.orderRouteDist.push({   
       order_Id: activeOrders[i].order_Id,
       order_Distance: totDist
    })
     console.log(this.orderRouteDist)    
  }

    console.log(result)
}

  initMap(selectedRoutes: IRoutes[])
  {
    this.destination=[];
    this.dirs=[]; 
    


    if(!(this.manOrders.length == selectedRoutes.length))
    {
      console.log(selectedRoutes)

      for(let ir = 0; ir < selectedRoutes.length; ir++)
      {
        if (this.isSelectedRoute(selectedRoutes[ir])) {
       console.log('route selected ',this.isSelectedRoute(selectedRoutes[ir]));
       this.waypoints = [];
      
        this.destination.push({
          lat: selectedRoutes[ir].orders[selectedRoutes[ir].orders.length-1].location.location_Latitude,
          lng: selectedRoutes[ir].orders[selectedRoutes[ir].orders.length-1].location.location_Longitude
        });

        for(let i = 0; i < selectedRoutes[ir].orders.length-1; i++)
        {
          this.waypoints.push({
            location: {
              lat: selectedRoutes[ir].orders[i].location.location_Latitude,
              lng: selectedRoutes[ir].orders[i].location.location_Longitude
            }
          });
        }

        //an array of colors is referenced for each route (this.str[ir])
        this.dirs.push({
          origin: this.origin,
          destination: this.destination[ir],
          waypoints: this.waypoints,
          renderOptions: { polylineOptions: { strokeColor: this.str[this.str.findIndex(d => d.route_Id === selectedRoutes[ir].route_Id)].route_color}}
        })
        console.log(this.dirs)

      }else {
        console.log('route selected ',this.isSelectedRoute(selectedRoutes[ir]));
        this.destination[ir] = this.destination.filter(x => x.route_Id !== selectedRoutes[ir].route_Id)
        console.log('initial destinations: ',this.destination);
        console.log('removing destination: ',this.destination.filter(x => x.route_Id !== selectedRoutes[ir].route_Id));
        console.log('final destinations: ',this.destination);
        for(let i = 0; i < selectedRoutes[ir].orders.length-1; i++)
        {
          this.waypoints = this.waypoints.filter(x => x.route_Id !== selectedRoutes[ir].route_Id);
        }
        
      }
    }

    }else{

      console.log(this.manOrders)

      
      for(let ir = 0; ir < this.manOrders.length; ir++)
      {
        if (this.isSelectedRoute(this.manOrders[ir])) {
       console.log('route selected ',this.isSelectedRoute(this.manOrders[ir]));
       this.waypoints = [];
      
        this.destination.push({
          lat: this.manOrders[ir].orders[this.manOrders[ir].orders.length-1].location.location_Latitude,
          lng: this.manOrders[ir].orders[this.manOrders[ir].orders.length-1].location.location_Longitude
        });

        for(let i = 0; i < this.manOrders[ir].orders.length-1; i++)
        {
          this.waypoints.push({
            location: {
              lat: this.manOrders[ir].orders[i].location.location_Latitude,
              lng: this.manOrders[ir].orders[i].location.location_Longitude
            }
          });
        }

        //an array of colors is referenced for each route (this.str[ir])
        this.dirs.push({
          origin: this.origin,
          destination: this.destination[ir],
          waypoints: this.waypoints,
          renderOptions: { polylineOptions: { strokeColor: this.str[this.str.findIndex(d => d.route_Id === this.manOrders[ir].route_Id)].route_color}}
        })
        console.log(this.dirs);

      }else {
        console.log('route selected ',this.isSelectedRoute(this.manOrders[ir]));
        this.destination[ir] = this.destination.filter(x => x.route_Id !== this.manOrders[ir].route_Id)
        console.log('initial destinations: ',this.destination);
        console.log('removing destination: ',this.destination.filter(x => x.route_Id !== this.manOrders[ir].route_Id));
        console.log('final destinations: ',this.destination);
        for(let i = 0; i < this.manOrders[ir].orders.length-1; i++)
        {
          this.waypoints = this.waypoints.filter(x => x.route_Id !== this.manOrders[ir].route_Id);
        }
        
      }
    }
    }

      
      for(let i = 0; i < this.manOrders.length; i++)
        {
         
        }
    
  }



  mapClicked($event: MouseEvent) {

  }

  ngOnInit(): void
  {

  }







  onSelectRoute(item: IRoutes, routeIndex: number) {

    console.log('route selected', this.isSelectedRoute(item))
    console.log('item | index', item, routeIndex)
    if (this.isSelectedRoute(item)) {
      console.log('route ', item)
      
      this.activeRoutes = this.activeRoutes.filter(x => x.route_Id !== item.route_Id);
      this.initMap(this.activeRoutes);
      console.log(this.activeRoutes);
    } else { 

      //logic of autoselect goes here
      console.log(item.orders);

      this.activeRoutes.push(item);
      this.initMap(this.activeRoutes)
     // this.activeRoutes[routeIndex].orders.push(item.orders);
      console.log(this.activeRoutes);
      
      
    }
    this.setRouteSelectAllState();
  }


  setRouteSelectAllState() {
    if (this.activeRoutes.length === this.manOrders.length) {
      this.selectRouteAllState = 'checked';
    } else if (this.manOrders.length !== 0) {
      this.selectRouteAllState = 'indeterminate';
    } else {
      this.selectRouteAllState = '';
    }
  }


  selectRouteAllChange($event) {
    if ($event.target.checked) {
    } else {
      this.activeRoutes = [...this.manOrders];
    }
    this.setRouteSelectAllState();
  }

  isSelectedRoute(r: IRoutes) {    
    return this.activeRoutes.findIndex(d => d.route_Id === r.route_Id) > -1;
  }

  
  onDetailToggle(event) {
  }
  
  onPage(event) {
  }

}
