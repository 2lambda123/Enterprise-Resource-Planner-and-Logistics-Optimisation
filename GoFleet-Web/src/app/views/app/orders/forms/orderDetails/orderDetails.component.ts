import { DefaultComponent } from './../../../dashboards/default/default.component';
import { switchMap } from 'rxjs/operators';
import { Observable, BehaviorSubject, interval } from 'rxjs';
import { environment } from './../../../../../../environments/environment';
import { Location } from './../../../routes/components/maps/maps.component';
import { Component, TemplateRef, OnDestroy, OnInit,ViewChild, AfterViewInit, AfterViewChecked } from '@angular/core';
import { AuthService } from 'src/app/shared/auth.service';
import { Router, ActivatedRoute, ParamMap, Resolve } from '@angular/router';
import { FormControl, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { carouselImages, carouselThumbs, ICarouselImage } from 'src/app/data/carousels';
import commentData, { IComment } from 'src/app/data/comments';
import questionData, { IQuestion } from 'src/app/data/questions';
import { AgmCoreModule, MapsAPILoader } from "@agm/core";
import * as geofirex  from 'geofirex';
import * as firebase  from 'firebase/app';
import {STEPPER_GLOBAL_OPTIONS} from '@angular/cdk/stepper';
import { MatStepper } from '@angular/material/stepper';
import * as Rx from 'rxjs/Rx'

import 'firebase/firestore';


export interface iLiveOrderLocation {
  driver_Id: number;
  longitude: number;
  latitude:  number;
}

export interface IBranch {
  branch_Id:       number;
  branch_Name:     string;
  branch_Location: ILocation;
}

// Generated by https://quicktype.io

export interface IRoutes {
  route_Id:        number;
  route_ETA:       string;
  route_Driver_Id: number;
  route_Active:   boolean;
  route_Completed: string;
  driver:         IDriver;
  orders:         Order[];
}

// Generated by https://quicktype.io

export interface IDriver {
  emp_Id:         number;
  emp_First_Name: string;
  emp_Last_Name:  string;
}


export interface Order {
  order_Id:              number;
  order_Sequence_Number: number;
  order_Delivered:       boolean;
  location:              ILocation;
}

//to display the order information

// Generated by https://quicktype.io

export interface IOrders {
   order_Id:              number;
  client:                IClient;
  location:              ILocation;
  order_Total_Volume:    number;
  order_Deliver_By_Date: string;
  order_Date_Placed:     string;
  order_Sequence_Number: number;
  order_Delivered:       boolean;
  order_Postponed:       boolean;
  order_Delayed:         boolean;
  items:                 ItemElement[];
}


export interface IClient 
{
  client_First_Name:          string;
  client_Last_Name:           string;
  client_Id_Number:           string;
  client_Business_Name:       string;
  client_Business_Reg_Number: string;
  client_Contact_Number:      string;
  client_Email:               string;
}

export interface ItemElement {
  item:             ItemItem;
  quantity_Ordered: number;
  combined_Volume:  number;
}

export interface ItemItem {
  stockItem_Name: StockItemName;
}

export enum StockItemName {
  Bricks = "Bricks",
  Cement = "Cement",
  Sand = "Sand",
}

export interface ILocation {
  location_Street:    string;
  location_Suburb:    string;
  location_City:      string;
  location_Zip_Code:  string;
  location_Longitude: number;
  location_Latitude:  number;
  location_Places_Id: string;
}


@Component({
  selector: 'app-orderDetails',
  templateUrl: './orderDetails.component.html',
  providers: [{
    provide: STEPPER_GLOBAL_OPTIONS, useValue: {displayDefaultIndicatorType: true}
  }]
})


export class orderDetailsComponent implements OnInit, AfterViewInit, AfterViewChecked, OnDestroy {


  detailImages: ICarouselImage[] = carouselImages;
  detailThumbs: ICarouselImage[] = carouselThumbs;

  points: Observable<any>;
  
  //information bar 
  
  @ViewChild('elseBlock') public elseBlock;
  @ViewChild('stepper') private myStepper: MatStepper;

  comments: IComment[] = commentData;
  questions: IQuestion[] = questionData;

 // navigationMode = new CustomNavigationMode();
  
  //map variables 
  public timer = interval(400);
  public subscribtionTimer;
  public driverLocation: iLiveOrderLocation;
  public driverLocationCo: iLiveOrderLocation;
  public manOrders : IRoutes[] =[];

  public manOrderData : IRoutes ;
  public manOrderCount : number = 0 ;

  branch : IBranch;
  branchcount: number = 0;

  //the route that the current order is stored
  orderRouteIndex;
  orderIndex;

  origin = {
    lat: 0.00,
    lng: 0.00
  };

  options;
  destination = {
    lat: 0.00,
    lng: 0.00
  };


    icon: {
        url: 'https://www.flaticon.com/premium-icon/icons/svg/2431/2431093.svg',
        scaledSize: {
          width: 40,
          height: 60
        }
    }

  public markerOptions = {
    origin: {
        draggable: true,
        infoWindow: 'Start'
    },
    destination: {
        opacity: 0.8,
        infoWindow: 'End'
    },
};

public renderOptions = {
  suppressMarkers: true,
  polylineOptions: { strokeColor: '#FF0000' }
}


  public direction = {
    
    
      origin: this.origin,
      destination: this.destination,
      renderOptions: this.renderOptions,
      markerOptions: this.markerOptions,
      travelMode: 'DRIVING'
  };
  
    //  unitSystem: google.maps.UnitSystem.METRIC

  Color = require('color');
  color;
  str = [];

  currentOrderID;
  currentOrderIndex;
  currentRouteIndex = 0;
//geofire instance for calculation
  geo;
  //order information
  allorders: IOrders[] = [];
  currentOrder: IOrders;
  currentOrderItemVolumes = [];
  ordercount: number = 0;
  allOrderIndex = 0;
  //always from the branch to current order
  orderHaverSineDist;
  orderBranchDist: number;
  //this only exist if an order is in a route
  orderRouteDist;
  routeArrivalTravel = '';
  routeDepartureTravel = '';
  routeDurationTravel = '';
  routeStepsTravel;

  //positions
  startingPoint: ILocation;
  endPoint: Order;


  constructor(private route: ActivatedRoute, private fb: FormBuilder, private authService: AuthService, private router: Router) 
  {

    this.loadRouteData();

    this.route.paramMap.subscribe((params: ParamMap)=> {
        this.currentOrderID = parseInt(params.get('id'));
    })  
  }


  ngAfterViewChecked() {
   
  }

  ngOnDestroy(){
    this.subscribtionTimer.unsubscribe();
  }

  ngAfterViewInit(): void {
    console.log(this.myStepper)

    this.authService.viewOrders().subscribe(orderdata=> {
    
      this.allorders = [];

   


      for(let key in orderdata)
        {

          if(orderdata.hasOwnProperty(key))
          {
            this.allorders.push(orderdata[key]);
          }
        }
        console.log(this.allorders)   
    
        this.allOrderIndex = this.allorders.findIndex(d => d.order_Id === this.currentOrderID);
        console.log(this.allorders[this.allOrderIndex])   

        if((this.allorders[this.allOrderIndex].order_Sequence_Number != 0) && (!this.allorders[this.allOrderIndex].order_Delivered) && (!this.allorders[this.allOrderIndex].order_Postponed))
        {
            //active
             console.log('active: ',this.allorders[this.allOrderIndex])  
              this.myStepper.next();
    
        }else if(this.allorders[this.allOrderIndex].order_Delivered)
          {
            //complete
             console.log('complete: ',this.allorders[this.allOrderIndex])   
             for(let i = 0; i < 4; i++)
             {
              this.myStepper.next(); 
             } 
          }else if((this.allorders[this.allOrderIndex].order_Delivered == false) && (this.allorders[this.allOrderIndex].order_Sequence_Number == 0))
            {
              //submitted
              
            }
       
      });
      

    /*console.log(this.wizard.currentStepIndex)
    console.log(this.wizard.wizardSteps[this.wizard.currentStepIndex])
    console.log(this.wizard.wizardSteps[this.wizard.currentStepIndex])
    */
  }


 
  ngOnInit() {

  }

  
  getfireDistance(origin:ILocation,destination:ILocation){
    console.log(origin,destination)
    return this.geo.distance(this.geo.point(origin.location_Latitude, origin.location_Longitude), this.geo.point(destination.location_Latitude,destination.location_Longitude))
  }

  mapClicked($event: MouseEvent) {

  }


  
  
    loadRouteData(pageSize: number = 10, currentPage: number = 1, search: string = '', orderBy: string = '') 
    {

    this.orderIndex = 0;
    this.orderRouteIndex = 0;
  
    this.authService.getBranch().subscribe(data=> {
      
      this.branch = {
        branch_Id: data.branch_Id,
        branch_Name: data.branch_Name,
        branch_Location: {
          location_City: data.branch_Location.location_City,
          location_Street: data.branch_Location.location_Street,
          location_Suburb: data.branch_Location.location_Suburb,
          location_Zip_Code: data.branch_Location.location_Zip_Code,
          location_Longitude: data.branch_Location.location_Longitude,
          location_Latitude: data.branch_Location.location_Latitude,
          location_Places_Id: data.branch_Location.location_Places_Id
        }
      };

      
  const config = environment.firebaseConfig;

  //geofire instance
  if (!firebase.apps.length) {
    firebase.initializeApp(config)
 }
  this.geo = geofirex.init(firebase);

//this center thing works
    const center = this.geo.point(this.branch.branch_Location.location_Latitude,this.branch.branch_Location.location_Longitude);
    const radius = 100;
    const field = 'pos';

      
      console.log('branch details: ',this.branch)
    },null,()=> {
     
      console.log("branch stored")
    });

    this.authService.viewOrders().subscribe(orderdata=> {
    
      this.allorders = [];

   


      for(let key in orderdata)
        {

          if(orderdata.hasOwnProperty(key))
          {
            this.allorders.push(orderdata[key]);
          }
        }

        console.log(this.allorders)
        this.allOrderIndex = this.allorders.findIndex(d => d.order_Id === this.currentOrderID);
        console.log(this.allOrderIndex)
        console.log(this.currentOrderID)

        if((this.allorders[this.allOrderIndex].order_Sequence_Number != 0) && (!this.allorders[this.allOrderIndex].order_Delivered) && (!this.allorders[this.allOrderIndex].order_Postponed))
        {
          this.currentOrder = this.allorders[this.allOrderIndex];
          //this order is classified as active so we set the status
          
          this.authService.ManagerRoutes().subscribe(data=> {
      
            console.log(data)
            this.manOrderData = data;
              for(let key in data)
              {
      
                if(data.hasOwnProperty(key))  
                {
                  this.manOrders.push(data[key]);
                  console.log(data[key])
                }
              }
            console.log(this.manOrders);
            console.log(this.manOrders.length-1);

            //the current route to be displayed on the map  
            //we have to get the length in the call

            //run a deeper if check-> && (!this.manOrders[this.orderRouteIndex].orders[this.orderIndex-1].order_Delivered) && (this.manOrders[this.orderRouteIndex])
           
           
            for(let ir = 0; ir < this.manOrders.length;ir++)
            { 
              console.log(this.manOrders[ir]);
              console.log(this.manOrders[ir].orders.findIndex(p => p.order_Id === this.currentOrderID));
                //this is confirmed that it will only set the routeindex once after it has checked all routes and matched the correct one
               if(this.manOrders[ir].orders.findIndex(p => p.order_Id === this.currentOrderID) > -1)
               {
                console.log(this.manOrders[ir].orders.findIndex(p => p.order_Id === this.currentOrderID));
                this.orderRouteIndex = ir;
                this.orderIndex = this.manOrders[ir].orders.findIndex(p => p.order_Id === this.currentOrderID);
           
                console.log(this.orderRouteIndex);
                console.log(this.orderIndex); 

                console.log(this.allOrderIndex );
                console.log(this.currentOrder);
                console.log(this.manOrders[this.orderRouteIndex].orders[this.orderIndex].order_Sequence_Number == 1);
      
                if(this.manOrders[this.orderRouteIndex].orders[this.orderIndex].order_Sequence_Number == 1)
                {

                  this.startingPoint = this.branch.branch_Location;
                  this.endPoint = this.allorders[this.allOrderIndex];
        
                  console.log('this order has route that has the branch as a starting point')
                   this.initMap(this.startingPoint,this.endPoint)
                }else
                {

                  this.startingPoint = this.manOrders[this.orderRouteIndex].orders[this.orderIndex-1].location;
                  this.endPoint = this.allorders[this.allOrderIndex];
        
                  console.log('this order has route that starts from prev to current order')
                   this.initMap(this.startingPoint,this.endPoint)
                }
               }
            } 
          
       
          });


        //a deeper check on the order, 
        //complete for next if
        
        }else if((this.allorders[this.allOrderIndex].order_Delivered == true))
        {


          //this order is not the same as getallorders so it doesnt have the items, we track it here
          this.currentOrder = this.allorders[this.allOrderIndex];



          console.log(this.allOrderIndex );
          console.log(this.currentOrder);

          
          this.startingPoint = this.branch.branch_Location;
          this.endPoint = this.allorders[this.allOrderIndex];

          //  initMap(origin: ILocation, destination: Order) 
          console.log('this order has route that has the branch as a starting point')
           this.initMap(this.branch.branch_Location,this.allorders[this.allOrderIndex])
     
           /*console.log(this.wizard)
           console.log(this.wizard.goToStep(1))
           this.wizard.goToStep(4);*/

           //next if checks if the order is submitted
        }else if((this.allorders[this.allOrderIndex].order_Delivered == false) && (this.allorders[this.allOrderIndex].order_Sequence_Number == 0))
        {


          //this order is not the same as getallorders so it doesnt have the items, we track it here
          this.allOrderIndex = this.allorders.findIndex(d => d.order_Id === this.currentOrderID);
          this.currentOrder = this.allorders[this.allOrderIndex];


          console.log(this.allOrderIndex );
          console.log(this.currentOrder);

          
          this.startingPoint = this.branch.branch_Location;
          this.endPoint = this.allorders[this.allOrderIndex];

          //  initMap(origin: ILocation, destination: Order) 
          console.log('this order has route that has the branch as a starting point')
           this.initMap(this.branch.branch_Location,this.allorders[this.allOrderIndex])
     
        }



         if(this.currentOrder.items)
         {
           for(let i = 0; i < this.currentOrder.items.length; i++)
           {
            this.currentOrderItemVolumes.push(Math.round((this.currentOrder.items[i].combined_Volume*10000 + Number.EPSILON) * 100) / 100)
           }
         }
         
/*
         //  initMap(origin: ILocation, destination: Order) 
         
         this.startingPoint = this.branch.branch_Location;
         this.endPoint = this.allorders[this.allOrderIndex];
         this.initMap( this.branch.branch_Location , this.allorders[this.allOrderIndex])
         */
    });

  }

  countRoutes (obj) {
    var count = 0;

    for (var property in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, property)) {
            count++;
        }
    }

    return count;
}

  initMap(origin: ILocation, destination: Order)
  {
    

    console.log('destination: ',destination, ' origin: ', origin)
    console.log(this.manOrders)
    this.direction.destination = {
      lat: destination.location.location_Latitude,
      lng: destination.location.location_Longitude
    }
    this.allOrderIndex = this.allorders.findIndex(p => p.order_Id === this.currentOrderID)
    

    //complete
    if((this.allorders[this.allOrderIndex].order_Delivered))
    {
         

      console.log("origin is a branch: ",origin)
      //this origin has not been assigned to a route 
      //still have to handle this from location in getallorders
      //find the order index in getallorders
      this.origin = {
        lat: origin.location_Latitude,
        lng: origin.location_Longitude
      }
      this.direction.markerOptions.origin.infoWindow = 'Starting point: Phaki Branch'
      this.direction.markerOptions.destination.infoWindow = 'Ending point: ' +  this.allorders[this.allOrderIndex].location.location_Suburb.toString()  + '<br/> Order ID: ' + this.allorders[this.allOrderIndex].order_Id.toString();
     //get distance between these points
     this.orderHaverSineDist = Math.round((this.getfireDistance(this.branch.branch_Location,this.allorders[this.allOrderIndex].location) + Number.EPSILON) * 100) / 100;
     this.orderBranchDist =  Math.round((this.calcBranch(this.branch.branch_Location,this.allorders[this.allOrderIndex].location) + Number.EPSILON) * 100) / 100;
   
    }else if((this.allorders[this.allOrderIndex].order_Sequence_Number > 0) && !this.allorders[this.allOrderIndex].order_Postponed && !this.manOrders[this.orderRouteIndex].route_Active)
    {
      //assigned but not active
      
      //we now tested if the origin recieved is an order with a sequence number no less than 1
      console.log(this.manOrders)
      if(this.manOrders[this.orderRouteIndex].orders[this.orderIndex].order_Sequence_Number == 1)
      {
        console.log("origin with index ",this.orderIndex,": ",origin, " has an index greater than 0")
        console.log("previous order: ",origin)
        console.log("previous order lat: ",origin)
        console.log("previous order lng: ",origin)
        this.origin = {
          lat: origin.location_Latitude,
          lng: origin.location_Longitude
        }
        this.direction.markerOptions.origin.infoWindow = 'Starting point: Phaki@' + this.branch.branch_Location.location_Suburb;
        this.direction.markerOptions.destination.infoWindow = 'Ending point: ' +  this.manOrders[this.orderRouteIndex].orders[this.orderIndex].location.location_Suburb.toString()  + '<br/> Order ID: ' + this.manOrders[this.orderRouteIndex].orders[this.orderIndex].order_Id.toString();
     
      //get distance between these points
      this.orderHaverSineDist =  Math.round((this.getfireDistance(this.branch.branch_Location,this.manOrders[this.orderRouteIndex].orders[this.orderIndex].location) + Number.EPSILON) * 100) / 100;
      this.orderBranchDist =  Math.round((this.calcBranch(this.branch.branch_Location,this.manOrders[this.orderRouteIndex].orders[this.orderIndex].location) + Number.EPSILON) * 100) / 100;
      this.orderRouteDist =  Math.round((this.calcRoute(this.manOrders[this.orderRouteIndex].orders[this.orderIndex-1].location,this.manOrders[this.orderRouteIndex].orders[this.orderIndex].location) + Number.EPSILON) * 100) / 100;
    
      }else
      {
        console.log("origin with index ",this.orderIndex,": ",origin, " has an index greater than 0")
        console.log("previous order: ",origin)
        console.log("previous order lat: ",origin)
        console.log("previous order lng: ",origin)
        this.origin = {
          lat: origin.location_Latitude,
          lng: origin.location_Longitude
        }
        this.direction.markerOptions.origin.infoWindow = 'Starting point: ' + this.manOrders[this.orderRouteIndex].orders[this.orderIndex-1].location.location_Suburb.toString()  + '<br/> Order ID: ' + this.manOrders[this.orderRouteIndex].orders[this.orderIndex-1].order_Id.toString();
        this.direction.markerOptions.destination.infoWindow = 'Ending point: ' +  this.manOrders[this.orderRouteIndex].orders[this.orderIndex].location.location_Suburb.toString()  + '<br/> Order ID: ' + this.manOrders[this.orderRouteIndex].orders[this.orderIndex].order_Id.toString();
     
      //get distance between these points
      this.orderHaverSineDist =  Math.round((this.getfireDistance(this.branch.branch_Location,this.manOrders[this.orderRouteIndex].orders[this.orderIndex].location) + Number.EPSILON) * 100) / 100;
      this.orderBranchDist =  Math.round((this.calcBranch(this.branch.branch_Location,this.manOrders[this.orderRouteIndex].orders[this.orderIndex].location) + Number.EPSILON) * 100) / 100;
      this.orderRouteDist =  Math.round((this.calcRoute(this.manOrders[this.orderRouteIndex].orders[this.orderIndex-1].location,this.manOrders[this.orderRouteIndex].orders[this.orderIndex].location) + Number.EPSILON) * 100) / 100;
    
      }

    } else if((this.allorders[this.allOrderIndex].order_Sequence_Number > 0) && !this.allorders[this.allOrderIndex].order_Postponed && this.manOrders[this.orderRouteIndex].route_Active )
    {
      //en route
      this.myStepper.next();
      console.log(this.manOrders);

     
      //an observable doesnt need to be subscribed just updated directly
      /*
        (async () => { 
          // Do something before delay
       
          while(true)
          {
              this.authService.getliveorderdriverlocation(this.currentOrderID)..subscribe(data => {
                  console.log(data);
                },null, () => {
                  (async () => { 
                    // Do something before delay
                    console.log('before delay')
            
                    await this.delay(1000);
            
                    // Do something after
                    console.log('after delay')
                })();
                });
    
          // Do something after
          
         }
      }
      )();
      var obs = Rx.Observable.interval(500)
           .take(5)
           .do(i => console.log(i) );

      this.driverLocation.subscribe(data => {
        this.driverLocationCo = data;
      })*/

     

      var arrivecount = 0;
      var completecount = 0;

      this.subscribtionTimer = this.timer.subscribe(n => {
        this.authService.getliveorderdriverlocation(this.currentOrderID).subscribe(data => {
          console.log(data);
          this.driverLocation = data;

          if((this.driverLocation.latitude == this.allorders[this.allOrderIndex].location.location_Latitude) && (this.driverLocation.longitude == this.allorders[this.allOrderIndex].location.location_Longitude) && (arrivecount == 0))
          {
             arrivecount++;
             this.myStepper.next();
          }
          
          if(this.allorders[this.allOrderIndex].order_Delivered && (completecount == 0))
          {
             completecount++;
             this.myStepper.next();
          }

        },null, () => {
          console.log('finished subscription');
        })
      });

      console.log(this.driverLocation)

      if(this.manOrders[this.orderRouteIndex].orders[this.orderIndex].order_Sequence_Number == 1)
      {
        console.log("origin with index ",this.orderIndex,": ",origin, " has an index greater than 0")
        console.log("previous order: ",origin)
        console.log("previous order lat: ",origin)
        console.log("previous order lng: ",origin)
        this.origin = {
          lat: origin.location_Latitude,
          lng: origin.location_Longitude
        }
        this.direction.markerOptions.origin.infoWindow = 'Starting point: Phaki@' + this.branch.branch_Location.location_Suburb;
        this.direction.markerOptions.destination.infoWindow = 'Ending point: ' +  this.manOrders[this.orderRouteIndex].orders[this.orderIndex].location.location_Suburb.toString()  + '<br/> Order ID: ' + this.manOrders[this.orderRouteIndex].orders[this.orderIndex].order_Id.toString();
     
      //get distance between these points
      this.orderHaverSineDist =  Math.round((this.getfireDistance(this.branch.branch_Location,this.manOrders[this.orderRouteIndex].orders[this.orderIndex].location) + Number.EPSILON) * 100) / 100;
      this.orderBranchDist =  Math.round((this.calcBranch(this.branch.branch_Location,this.manOrders[this.orderRouteIndex].orders[this.orderIndex].location) + Number.EPSILON) * 100) / 100;
      this.orderRouteDist =  Math.round((this.calcRoute(this.manOrders[this.orderRouteIndex].orders[this.orderIndex-1].location,this.manOrders[this.orderRouteIndex].orders[this.orderIndex].location) + Number.EPSILON) * 100) / 100;
    
      }else
      {
        console.log("origin with index ",this.orderIndex,": ",origin, " has an index greater than 0")
        console.log("previous order: ",origin)
        console.log("previous order lat: ",origin)
        console.log("previous order lng: ",origin)
        this.origin = {
          lat: origin.location_Latitude,
          lng: origin.location_Longitude
        }
        this.direction.markerOptions.origin.infoWindow = 'Starting point: ' + this.manOrders[this.orderRouteIndex].orders[this.orderIndex-1].location.location_Suburb.toString()  + '<br/> Order ID: ' + this.manOrders[this.orderRouteIndex].orders[this.orderIndex-1].order_Id.toString();
        this.direction.markerOptions.destination.infoWindow = 'Ending point: ' +  this.manOrders[this.orderRouteIndex].orders[this.orderIndex].location.location_Suburb.toString()  + '<br/> Order ID: ' + this.manOrders[this.orderRouteIndex].orders[this.orderIndex].order_Id.toString();
     
      //get distance between these points
      this.orderHaverSineDist =  Math.round((this.getfireDistance(this.branch.branch_Location,this.manOrders[this.orderRouteIndex].orders[this.orderIndex].location) + Number.EPSILON) * 100) / 100;
      this.orderBranchDist =  Math.round((this.calcBranch(this.branch.branch_Location,this.manOrders[this.orderRouteIndex].orders[this.orderIndex].location) + Number.EPSILON) * 100) / 100;
      this.orderRouteDist =  Math.round((this.calcRoute(this.manOrders[this.orderRouteIndex].orders[this.orderIndex-1].location,this.manOrders[this.orderRouteIndex].orders[this.orderIndex].location) + Number.EPSILON) * 100) / 100;
    
      }
    } else 
      {
        //upcoming AND RECIEVED
        console.log("origin with index ",this.orderIndex,": ",origin," is equal to 0 and deserves a branch origin")
        //this origin has not been assigned to a route 
        this.origin = {
          lat: this.branch.branch_Location.location_Latitude,
          lng: this.branch.branch_Location.location_Longitude
        };
        this.direction.markerOptions.origin.infoWindow = 'Starting point: Phaki Branch'   
        this.direction.markerOptions.destination.infoWindow = 'Ending point: ' +  this.allorders[this.allOrderIndex].location.location_Suburb.toString()  + '<br/> Order ID: ' + this.allorders[this.allOrderIndex].order_Id.toString();
   
        console.log("origin ",this.origin,navigator.geolocation," is now a branch location")
        //get distance between these points
        this.orderHaverSineDist = Math.round((this.getfireDistance(this.branch.branch_Location,this.allorders[this.allOrderIndex].location) + Number.EPSILON) * 100) / 100;
        this.orderBranchDist =  Math.round((this.calcBranch(this.branch.branch_Location,this.allorders[this.allOrderIndex].location) + Number.EPSILON) * 100) / 100;
        this.orderRouteDist =  this.orderBranchDist;
      };
  
    
    
  }

  
  calcBranch(origin:ILocation,destination:ILocation) {

    var directionsService = new google.maps.DirectionsService();
    
    var distresult : {
      result: google.maps.DirectionsResult,
      status:  google.maps.DirectionsStatus
    };

    var thedistance: number = 0;


    console.log(origin,destination)
    
    var request = {
      origin: { lat: origin.location_Latitude, lng: origin.location_Longitude },
      destination: { lat: destination.location_Latitude , lng: destination.location_Longitude},
      waypoints: null,
      travelMode: google.maps.TravelMode.DRIVING
    };

      directionsService.route(
       request, 
       (result: google.maps.DirectionsResult,
        status:  google.maps.DirectionsStatus) => this.calcBranchdist(result)
      );

    //convert to number and return
    
        console.log(distresult)
    return thedistance;
      
  }

  delay(ms: number) {
    return new Promise( resolve => setTimeout(resolve, ms) );
}

  calcRoute(origin:ILocation,destination:ILocation) {

    var directionsService = new google.maps.DirectionsService();
    
    var distresult : {
      result: google.maps.DirectionsResult,
      status:  google.maps.DirectionsStatus
    };

    var thedistance: number = 0;


    console.log(origin,destination)
    
    var request = {
      origin: { lat: origin.location_Latitude, lng: origin.location_Longitude },
      destination: { lat: destination.location_Latitude , lng: destination.location_Longitude},
      waypoints: null,
      travelMode: google.maps.TravelMode.DRIVING
    };

    
    if(this.manOrders[this.orderRouteIndex].orders.findIndex(d => d.order_Id === this.currentOrderID) > 0)
    {
      directionsService.route(
       request, 
       (result: google.maps.DirectionsResult,
        status:  google.maps.DirectionsStatus) => this.calcRoutedist(result)
      );
    }else if(this.manOrders[this.orderRouteIndex].orders.findIndex(d => d.order_Id === this.currentOrderID) == 0){

      directionsService.route(
        {
          origin: { lat: this.branch.branch_Location.location_Latitude, lng: this.branch.branch_Location.location_Longitude },
          destination: { lat: destination.location_Latitude , lng: destination.location_Longitude},
          waypoints: null,
          travelMode: google.maps.TravelMode.DRIVING
        }, 
        (result: google.maps.DirectionsResult,
         status:  google.maps.DirectionsStatus) => this.calcRoutedist(result)
       );
    }

    //convert to number and return
    
        console.log(distresult)
    return thedistance;
      
  }
  instructions = [];
calcRoutedist(result: google.maps.DirectionsResult): void
{
    this.orderRouteDist = +result.routes[0].legs[0].distance.text.toString().split(' ')[0];
    this.routeDurationTravel = result.routes[0].legs[0].duration.text.toString();
    this.routeStepsTravel = result.routes[0].legs[0].steps;
    for(let i = 0; i < this.routeStepsTravel.length; i++)
    {
      //"Turn <b>left</b><div style="font-size:0.9em">Restricted-usage road</div>"
      this.instructions.push(this.routeStepsTravel[i].instructions.toString().split('<b>').toString().split('</b>').toString().split('<div style="font-size:0.9em">').toString().split('</div>').toString().split('/<wbr/>'))
    }
    console.log(result,this.routeArrivalTravel,this.routeDepartureTravel,this.routeDurationTravel)
}

calcBranchdist(result: google.maps.DirectionsResult): void
{
    this.orderBranchDist = +result.routes[0].legs[0].distance.text.toString().split(' ')[0]

    console.log(result)
}
  /*addMapsScript() {
    if (!document.querySelectorAll(`[src="${environment.googleApi}"]`).length) { 
      document.body.appendChild(Object.assign(
        document.createElement('script'), {
          type: 'text/javascript',
          src: environment.googleApi
        }));
    } 
  }*/

}
 

